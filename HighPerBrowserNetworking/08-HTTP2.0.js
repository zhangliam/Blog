/*

    
  -- 目的

    1. 通过支持请求&响应的多路复用来减少延迟
    2. 通过压缩HTTP首部字段将协议降至最低
    3. 增加对请求优先级和服务端推送的支持



  
  -- 二进制分帧层(核心) => 定义如何封装HTTP消息在客户端&服务端间传输


    解决: HTTP1.x队首阻塞问题, 消除并行处理&发送及响应多个连接依赖


    HTTP1.0 以换行符作为纯文本分割符 
    HTTP2.0 将所有传输信息分割为更小消息&帧, 并采用二进制格式编码


    流 => 已建立连接上双向字节流
    消息 => 与逻辑消息对应的完整一系列数据帧
    帧 => 2.0通信最小单位, 每个帧包含帧首部, 至少也标识当前帧所属流


    基本概念
      a. 所有通信在一个TCP连接上完成
      b. 流是连接中一个虚拟信道, 可以承载双向消息; 每个流都有唯一整数标识符
      c. 消息指逻辑上HTTP消息, 比如请求, 响应等, 由一或多个帧组成
      d. 帧是最小通信单位, 承载特定类型数据, 如HTTP首部, 负荷等


  -- 多向请求 & 响应
      客户端&服务器可以把HTTP消息分解为互不依赖端的帧, 乱序发送, 另一端重新组合起来
      巨大提升体现在:
        a. 可并行交错发送请求, 请求中间互不影响
        b. 可并行交错发送响应, 响应中间互不干扰
        c. 只使用一个连接即可并行发送多个请求&响应
        d. 消除非必要延迟, 减少页面加载时间
        e. 不必绕过HTTP1.x限制做很多工作
      tips: 解决HTTP1.x限制所做的优化工作(拼接文件, 图片精灵, 域名分区等), 类似通过减少TCP连接数量, HTTP2.0减会减少客户端&服务端CPU及内存占用


  -- 请求优先级
      0 => 最高优先级
      2的31次方-1 => 最低优先级
      有了这个优先值, 客户端&服务端可以在处理不同流时采取不同策略, 以最优方式发送流, 消息和帧
      应用:现代浏览器都会基于资源的类型以及它在页面中位置排定请求的优先次序, 甚至通过之前访问来学习优先级模式(之前渲染被某资源阻塞, 下次访问可能赋予最高优先级)


  -- 每个来源一个连接 => 所有数据流共用一个连接体, 有效使用TCP连接


  -- 流量控制
      流量控制基于每一跳进行, 非端到端控制
      流量控制基于窗口更新帧进行
      流量控制基于窗口大小通过WINDOW_UPDATE帧更新, 这个字段指定流ID和窗口大小递增值
      流量控制有方向性, 接收方可根据自身情况为每个流乃至整个窗口设置大小递增值
      流量控制可以由接收方禁用


  -- 服务器推送(推送遵守同源策略)
      背景: HTTP2.0连接后, 客户端&服务端交换SETTINGS帧, 限定双向并发流最大数量. 因此客户端可限定推送流数量, 或设置0禁止服务端推送
      资源插入文档中, 就是将资源推送给客户端, 而无需客户端请求. 在HTTP2.0中, 唯一不同为把这个过程从应用中拿出来, 放到协议本身来实现

      好处:
        a. 客户端可缓存推送的资源
        b. 客户端可拒绝*
        c. 推送资源可由不同页面共享
        d. 服务器可按优先级推送资源

      PUSH_PROMISE(推送承诺帧)组成: 
        Pad Length - 8位字段, 包含帧的长度
        R - 单个保留位
        Promised Stream ID - 无符号31位整数, 标识承诺流ID
        Header Block Fragment - 标头块片段, 包含请求标头字段, 承诺推送的资源路径
        Padding - 填充8位字节

      RST_STREAM(流重置帧)
        如Client收到推送承诺PUSH_PROMISE帧, 而且本地检测到对应资源缓存, 那么Client会发送RST_STREAM("Error code=x"")拒绝该流

      该功能也可作为性能优化-网络层面因素之一, 相比HTTP1.x嵌入资源, 此项特性可减少不同类型资源加载"空闲时间(Idle)"更快展示页面元素


  -- 首部压缩
      a. HTTP2.0在客户&服务端使用“首部表”来跟踪存储之前发送的键-值对, 相同数据不再通过每次请求&响应发送
      b. 首部表在HTTP2.0连接存续期内始终存在, 由客户端&服务器共同渐进更新
      c. 每个新的首部键要么追加当前表末尾, 要么替换表中值
      
      于是HTTP2.0两端都知道已经发送了哪些首部, 针对之前数据只编码发送差异数据


  -- 二进制分帧简介
      所有帧都共享一个8字节的首部, 包含帧的长度, 类型, 标志, 还有一个保留位和一个31位的流标识符
      a. 16位的长度前缀意味一帧大约可以携带64KB数据, 不包含8字节首部
        tips: 技术上决定了每帧数据净荷最多可达2的16次方-1(64KB), 但为减少队首阻塞, HTTP2.0标准要求DATA帧不能超过2的14次方-1(16KB)超过即分帧发送. 
      b. 8位类型决定如何解释帧其余部分内容
      c. 8位标志字段允许不同帧类型定义特定于帧的消息标志
      d. 1位保留字段始终为0
      e. 31位流标识符唯一标识HTTP2.0的流

  
  -- 发起新流
      发送应用数据前, 必须创建一个新流随之发送相应元数据, 比如流优先级, HTTP首部等. HTTP2.0协议规定客户端&服务端都可发起新流, 所以两种可能
        a. 客户端通过发送HEADERS帧来发起新流, 帧里含有新流ID的公用首部, 可选的31位优先值, 以及一组HTTP键-值对首部
        b. 服务器通过发送PUSH_PROMISE帧来推送流, 这个帧与HEADER帧等效, 但它包含“要约流ID”, 没有优先值

      这两种帧的类型字段都只用于沟通新流的元数据，净荷会在DATA帧中单独发送。同样，由于两端都可发起新流，流计数器偏置: 客户端发起的流具有偶数ID，服务器的流具有奇数ID。这样两端流ID不会冲突，而且各自持有一个简单计数器，每次发起新流时递增ID即可. 

















*/