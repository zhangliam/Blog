/*

    
  -- 目的

    1. 通过支持请求&响应的多路复用来减少延迟
    2. 通过压缩HTTP首部字段将协议降至最低
    3. 增加对请求优先级和服务端推送的支持

  
  -- 二进制分帧层(核心) => 定义如何封装HTTP消息在客户端&服务端间传输

    解决: HTTP1.x队首阻塞问题, 消除并行处理&发送及响应多个连接依赖


    HTTP1.0 以换行符作为纯文本分割符 
    HTTP2.0 将所有传输信息分割为更小消息&帧, 并采用二进制格式编码


    流 => 已建立连接上双向字节流
    消息 => 与逻辑消息对应的完整一系列数据帧
    帧 => 2.0通信最小单位, 每个帧包含帧首部, 至少也标识当前帧所属流


    基本概念
      a. 所有通信在一个TCP连接上完成
      b. 流是连接中一个虚拟信道, 可以承载双向消息; 每个流都有唯一整数标识符
      c. 消息指逻辑上HTTP消息, 比如请求, 响应等, 由一或多个帧组成
      d. 帧是最小通信单位, 承载特定类型数据, 如HTTP首部, 负荷等


    多向请求 & 响应
      客户端&服务器可以把HTTP消息分解为互不依赖端的帧, 乱序发送, 另一端重新组合起来
      巨大提升体现在:
        a. 可并行交错发送请求, 请求中间互不影响
        b. 可并行交错发送响应, 响应中间互不干扰
        c. 只使用一个连接即可并行发送多个请求&响应
        d. 消除非必要延迟, 减少页面加载时间
        e. 不必绕过HTTP1.x限制做很多工作
      tips: 解决HTTP1.x限制所做的优化工作(拼接文件, 图片精灵, 域名分区等), 类似通过减少TCP连接数量, HTTP2.0减会减少客户端&服务端CPU及内存占用


    请求优先级
      0 =>最高优先级
      2的31次方-1 => 最低优先级
      有了这个优先值, 客户端&服务端可以在处理不同流时采取不同策略, 以最优方式发送流, 消息和帧
      应用:现代浏览器都会基于资源的类型以及它在页面中位置排定请求的优先次序, 甚至通过之前访问来学习优先级模式(之前渲染被某资源阻塞, 下次访问可能赋予最高优先级)


    每个来源一个连接 => 所有数据流共用一个连接体, 有效使用TCP连接


    流量控制
      流量控制基于每一跳进行, 非端到端控制
      流量控制基于窗口更新帧进行
      流量控制基于窗口大小通过WINDOW_UPDATE帧更新, 这个字段指定流ID和窗口大小递增值
      流量控制有方向性, 接收方可根据自身情况为每个流乃至整个窗口设置大小递增值
      流量控制可以由接收方禁用


    服务器推送(推送遵守同源策略)
      背景: HTTP2.0连接后, 客户端&服务端交换SETTINGS帧, 限定双向并发流最大数量. 因此客户端可限定推送流数量, 或设置0禁止服务端推送
      资源插入文档中, 就是将资源推送给客户端, 而无需客户端请求. 在HTTP2.0中, 唯一不同为把这个过程从应用中拿出来, 放到协议本身来实现

      好处:
        a. 客户端可缓存推送的资源
        b. 客户端可拒绝*
        c. 推送资源可由不同页面共享
        d. 服务器可按优先级推送资源

      PUSH_PROMISE(推送承诺帧)组成: 
        Pad Length - 8位字段, 包含帧的长度
        R - 单个保留位
        Promised Stream ID - 无符号31位整数, 标识承诺流ID
        Header Block Fragment - 标头块片段, 包含请求标头字段, 承诺推送的资源路径
        Padding - 填充8位字节

      RST_STREAM(流重置帧)
        如Client收到推送承诺PUSH_PROMISE帧, 而且本地检测到对应资源缓存, 那么Client会发送RST_STREAM("Error code=x"")拒绝该流

      该功能也可作为性能优化-网络层面因素之一, 相比HTTP1.x嵌入资源, 此项特性可减少不同类型资源加载"空闲时间(Idle)"更快展示页面元素
      















*/