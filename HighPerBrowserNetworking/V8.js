/*


    ****** V8垃圾回收机制 & 内存机制


    -- V8主要垃圾回收算法
      
      策略: 基于分代式垃圾回收机制

      内存分代

        新生代: 存活时间较短的对象
        老生代: 存活时间较长或常驻内存的对象
    
        新生代内存空间(max-new-space-size) + 老生代内存空间(max-old-space-size) = V8堆整体大小
        源码计算V8最大堆内存空间为
          4 * reserved_semispace_size_ + max_old_generation_size_
        
        新生代内存由2个reserved_semispace_size所构成, 64位/16M, 32位/8M

        操作系统内存 / 新生代 / 老生代 / 占用内存         
        32G           32M    1400M   1464M
        64G           16M    700M    732M


      新生代Scavenge算法进行垃圾回收

            cheney算法(核心)
              将堆内存一分为二, 每一部分空间为semispace, 一个处于使用中, 一个属于闲置状态. 处于使用状态semispace空间为From空间, 处于闲置状态semispace为To空间. 当分配对象时, 先在From空间中进行分配. 开始垃圾回收时, 检查From空间中存活对象复制到To空间, 释放非存活对象. 完成之后, From & To 空间角色对换. 简而言之, 在垃圾回收过程中, 通过将存活对象在两个semispace空间进行复制. 

            Scavenge评价
              只能使用堆内存一半, 这是由划分空间&复制机制所决定的, 但该算法只复制存活对象, 在生命周期短的场景存活对象占少部分, 时间效率上有优异的表现. 典型的牺牲空间换时间算法, 无法大规模应用到垃圾回收中, 非常适合新生代中, 新生代生命周期较短比较适合. 


      晋升(新生代移动老生代)
          
        当一个对象经过多次复制依然存活时, 它将会认为是生命周期较长的对象. 将会从新生代移动到老生代中采用新的算法进行管理. 

        晋升条件: 
          1. 是否经过Scavenge回收
          2. To空间内存占用比超过限制(限制值25% - 回收完成, To空间将变成From空间, 接下来内存分配将在这个空间进行, 如占比过高, 影响后续内存分配)


      老生代回收算法

        Mark-Sweep(标记-清除)

          标记阶段遍历堆中所有对象, 并标记活着的对象, 在随后的清除阶段, 只清除没有被标记的对象.
          可以看出Scavenge只复制活着的对象, Mark-Sweep只清理死亡对象. 活对象在新生代中只占较小部分, 死对象在老生代中只占小部分, 这是两种回收方式高效之处.

          问题: 进行标记清除后, 内存空间会存在不连续情况. 这种内存碎片会对后续内存分配造成问题, 因为可能需要分配空间一个大对象, 这时所有的碎片空间都无法完成分配, 则提前触发垃圾回收, 而这次回收是不需要的

        Mark-Compact(标记-整理)

          目的: 解决内存碎片问题
          在整理的过程中, 将活着的对象往一端移动, 移动完成后, 直接清掉存活对象边界外的内存区域完成回收.


        总结: Mark-Sweep & Mark-Compact之间, 由于Mark-Compact需要移动对象, 所以它的执行速度不可能很快, 所以取舍上, V8主要使用Mark-Sweep, 在空间不足从新生代晋升过来的对象进行分配时才使用Mark-Compact.


      Incremental Marking(增量标记)
          
        背景: 为了避免JS应用逻辑和垃圾回收器看到不一致情况, 垃圾回收三种算法都需要将应用逻辑暂停下来, 待执行完垃圾回收再恢复执行应用逻辑, 这种行为称为全停顿(stop-the-world). 新生代中垃圾回收, 一次垃圾回收只收集新生代, 由于配置较小, 其中存活对象较少, 即便全停顿倒影响不大. 但V8老生代通常配置较大, 且存活对象多, 全堆执行标记清除&整理造成停顿比较可怕需改善. 

        为了降低全堆垃圾回收带来的停顿时间, V8先从标记阶段入手, 将原本需一口气完成的动作改为增量标记, 拆分为许多小"步进", 让JS应用逻辑执行一小会, 垃圾回收和应用逻辑交替执行直到标记阶段完成. 后续引入延迟清理&增量式整理, 让清理和整理动作也变成增量式.
        同时计划引入并行标记&整理, 进一步利用多核性能降低每次停顿时间. 













*/