/*



	设计原则 & 编程技巧
	通常有: 单一职责原则, 里氏替换原则, 依赖倒置原则, 接口隔离原则, 合成复用原则, 最少知识原则



	*单一职责原则(SRP原则) => 一个对象(方法)只做一件事情

		- 涉及: 代理模式, 迭代器模式, 单例模式, 装饰者模式

		- 何时分离职责: 
			a. 随着需求变化, 两个职责总是同时变化, 那就不必分离它们(eg: ajax xhr创建&xhr发送请求)
			b. 职责的变化轴线仅当它们确定会发生变化时才具有意义, 即使两个职责已经耦合一起, 但它们没有发生改变征兆即没必要分离

		- 优缺点: 
			pros. 降低了单个类或者对象复杂度, 按照职责把对象分解成更小粒度, 有助于代码的复用, 也有利于单元测试. 当一个职责变更不影响其他
			cons. 增加编码复杂度, 职责分解成更小粒度之后, 实际上也增大了对象之间相互联系的难度

			
	
	*最少知识原则 => 一个实体应当尽可能少地与其他实体发生相互作用

		- 涉及: 中介者模式, 外观模式

		- 建议: 该原则要求设计程序时, 应当尽量减少对象间交互. 如两个对象间不必彼此通信, 那两个对象就不要发生直接相互联系.
		常见做法为引入第三方对象, 来承担这些对象之间通信作用. 如对象需要向另一个对象发起请求, 可通过第三方来实现即可. 

		- 封装在最少知识原则中的体现:
			封装在很大程度上表达的是数据的隐藏. 一个模块或者对象可以将内部数据或实现细节隐藏起来, 只暴露必要的接口API供外界使用. 
			对象之间难免联系, 当一个对象必须引用另一个对象的时候, 只暴露必要接口, 让对象之间联系限制在最小范围内. 



	*开放-封闭原则 => 软件实体(类, 模块, 函数)等应该是可以扩展的, 但是不可修改

		- 涉及: 发布-订阅模式, 模版方法模式, 策略模式, 代理模式, 职责链模式

		-	思想: 当需改变程序功能或新增功能时候, 可以使用增加代码的方式, 但不允许修改源代码(eg: AOP)

		- 核心: "找出变化的地方", 将系统中稳定不变的部分和容易变化的部分隔离开来. 在系统的演变过程中, 只需替换容易变化的部分,
		如这些部分是已经封装好的, 那么替换起来相对容易, 变化之外就是稳定的部分, 系统演变过程中, 稳定部分是无需改变的.

		- 合理利用 "放置挂钩" & "回调函数" 来遵守该原则
			放置挂钩: 模版方法模式中在父类某个容易变化的地方放置挂钩(hook), 挂钩的返回结果由具体的子类决定.
			回调函数: 把一部分易于变化的逻辑封装在回调函数里, 然后把回调函数当作参数传入稳定和封闭的函数中, 回调函数执行则产生不同结果.

		- 建议: 
			1. 挑选出最容易变化的地方, 然后构造抽象来封闭这些变化
			2. 在不可避免发生修改的时候, 尽量修改相对容易的地方



	代码重构建议: 

		1. 提炼函数 => 避免出现超大函数, 独立出来函数有助于代码复用, 独立出来函数更容易覆写, 独立出来函数如果有良好命名则起到注释作用
		2. 合并重复条件片段
		3. 条件分支语句提炼函数
		4. 合理使用循环	
		5. 提前让函数退出嵌套条件分支
		6. 传递对象参数替代过长参数列表
		7. 尽量减少参数数量
		8. 少用三目运算符
		9. 合理使用链式调用
		10. 分解大型类
		11. 用return退出多重循环

		

*/